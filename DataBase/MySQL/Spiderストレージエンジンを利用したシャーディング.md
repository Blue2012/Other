# MySQL Spiderストレージエンジンを利用した水平分散処理

前々から勉強してみたいと考えていたMySQLのシャーディング処理について実際に環境を構築して学習を進めてみようと思う。
学習に当たっては以下のサイトを参考にして、学習を進めてみた。

http://www.otwo.jp/blog/mysql-spider/

まず、シャーディングとは何なのか？

__「シャーディング」　＝「特定のデータ項目の剰余や範囲などのルールにより1つのテーブルのデータを複数のDBに分散して保持すること」__

![image](https://user-images.githubusercontent.com/18514297/90956474-f052ca00-e4c1-11ea-9855-16d0201a1aea.png)

大量のトランザクションを一つのデータベース、一つのサーバーで実施すると当然ですが、そのサーバーにかかる負荷は高くなります。
シャーディングを行うことでその大量のトランザクションを複数のサーバーで分散することが可能になる。

どんな技術にも共通して言えることだが、当然、メリットとデメリットが存在した技術である。

__■メリット__

・拡張性が高い
シャーディングのメリットは何よりもこれに尽きます。
ゲームサーバーでは更新によるマスターDBのI/O負荷がボトルネックになることが多々あります。
参照の負荷であればスレーブの台数を増やすことで軽減できますが、更新の負荷はそうもいきません。

DBのストレージを高速ディスク（SSDやioDriveのような）に変えたり、
DBを垂直分割（機能単位などで1つのDBにあるテーブル群を複数のDBに分ける）する対策が有効ですが、
いずれも変更には大掛かりな実装変更や移行が発生し、アクティブユーザーの増加により頭打ちが訪れます。

DBをユーザーのIDでシャーディングしている場合、DBを増やすことで更新負荷を複数のサーバーに分散することができるため、
アクティブユーザーの増減によるDB性能の拡張性（縮退も）が高いです。

・ALTER TABLEが速い
サービスを長く運営していると悩みの種になるのが、DBの項目追加や削除といったテーブル定義の変更（ALTER TABLE）です。
データ量の多いテーブルでは項目を1つ追加するのに数時間かかることもざらです。これはALTER TABLEでは内部的に以下の処理を行っているためです。

　１．変更後の定義でテーブルの新規作成（CREATE TABLE）
　２．変更前のテーブルから変更後のテーブルへデータの全件登録（INSERT）
　３．変更前のテーブルと変更後のテーブルの名前の入れ替え（RENAME）
　４．変更前のテーブルの削除（DROP TABLE）
　５．上記の2の処理時間はデータ量に依存し、データや制約が多いテーブルほど時間がかかります。

n台のDBでシャーディングしている場合は単純計算で1台当たりのデータ量が1/nとなり、
複数台のDBで平行してALTERを実行することで処理時間が1/nになることを期待できます。
（レプリケーション完了までの時間を考えると1/2n）

これら、いずれも強力なメリットといえる。

__■デメリット__

・オートインクリメント
シャーディング環境ではオートインクリメント値の採番が面倒です。
というのは、分散する各サーバーで別々にオートインクリメントでIDを採番した場合、サーバー間でIDの重複が発生するためです。
これを回避するために、別に用意した分散しないDBでオートインクリメント値の採番だけを行い、
採番した値で分散する各サーバーにデータを登録するといった対策が必要となります。

・サーバーを跨ぐクエリ
サーバーを跨いだ結合（JOIN）、ソート（ORDER BY）、集計（GROUP BY）を発行する際に、
複数のDBを串刺しで横断検索して得た結果をプログラムでごにょごにょする必要があり、
シャーディングしている環境では実装が複雑になりがちで、処理速度も不安です。
上記のようなサーバーを跨ぐ処理は設計時点で極力減らす、シャーディングしないDBに保持するなどの配慮が必要です。

・運用コスト
ゲームサーバーのDBはマスター、スレーブの複数台で構成するのが一般的です。
シャーディングする場合はマスター、スレーブをセットで必要となり、
例えばマスター1台、スレーブ2台、ユーザーデータをn台のサーバーにシャーディングする場合、n×3台のサーバーが必要です。
サーバーの台数が増えるとインフラ費用が上がるのはもちろんですが、
障害点が増えるため障害発生の確率が上がる、パッチ適用などサーバー保守作業の手間が増えるなどのデメリットも発生します。

・トランザクション管理
複数のDBに跨って更新クエリを発行する際に、一方の更新クエリが正常にコミットされ、
もう一方の更新クエリがエラーとなった場合にデータの不整合が発生します。
commitのタイミングをなるべく近くすることで、ほとんどの場合は回避が可能ですが、commitでエラーが発生した場合は回避できません。
障害時に備えて万全を期すならXAトランザクションによる二相コミットのような特別な配慮が必要となります。

メリットも強力だが、デメリットも強力ですね(笑)
アプリケーションの設計、コスト、フォールトトレラント※のいずれもビジネスに与える影響は半端ないです。
※シャーディング自体がフォールトトレラントの技術であるため、XAトランザクションによる2相コミットなどは
　フォールトトレラントのフォールトトレラントとなるのでしょうか…2相コミットメントは以下の画像を参照。

![image](https://user-images.githubusercontent.com/18514297/90956726-17120000-e4c4-11ea-818e-2dbcd673f58d.png)

__Spiderエンジンとは__

ローカルのSpiderノードとリモートの複数のデータノードで構成する。
SpiderストレージエンジンのSpiderノードは予め決められたルールにより各データノードにデータを振り分け、
データノードはInnodb※などのストレージエンジンで実データを格納する。

※Innodbは以下の画像を参照。

![image](https://user-images.githubusercontent.com/18514297/90956742-40329080-e4c4-11ea-8c36-7336de864af9.png)

データノードは普通のInnoDBとなんら変わらないので、Spiderノードを経由しなくとも直接参照、更新することが可能です。
（データノードを直接更新する場合、データノードを跨いだ制約チェックではエラーになりませんが、データ不整合が発生するので注意）
参照、更新は通常のDBと同様に行うことができる。ただし、直接、片方だけのDBのテーブルに対して、更新を行う以上、不整合が発生する。

SpiderはHA機能を備えており、データノードの自動フェールオーバーにも対応しています。

![image](https://user-images.githubusercontent.com/18514297/90956885-5e4cc080-e4c5-11ea-8fa7-198d10494f08.png)

__デメリットの緩和__

・オートインクリメント
Spiderノード経由でデータを登録すると、Spiderノードによりオートインクリメント値が採番されるため、特別な採番の仕組みを設ける必要がありません。

・サーバーを跨ぐクエリ
Spiderはデータノードを跨いだ結合、ソート、集計に対応しているため、プログラムで特別な考慮なく、サーバーを跨ぐクエリを発行できます。
ただし、データノードが多いほど処理時間は長くなるので、いずれにせよデータノードを跨ぐクエリを極力控える設計や1か所にデータをまとめる構成が重要となります。

・トランザクション管理
SpiderはXAトランザクションに対応しており、データノードを跨いだ更新クエリでデータの一貫性を保つことができます。
（データノード側でもXAトランザクションの設定が必要なはずです。）

  
